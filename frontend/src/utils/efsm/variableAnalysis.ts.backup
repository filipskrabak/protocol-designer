// Variable Analysis and Constraint Checking for EFSM

import type {
  EFSMVariable,
  FSMEdge,
  FSMNode,
  GuardWarning,
  VariableState,
} from '@/contracts/models';
import { parseGuardExpression, parseActionExpression, evaluateGuard } from './guardEvaluator';

/**
 * Analyze all guards and actions in the FSM for potential issues
 */
export function analyzeEFSM(
  nodes: FSMNode[],
  edges: FSMEdge[],
  variables: EFSMVariable[]
): {
  warnings: GuardWarning[];
  stats: {
    totalGuards: number;
    totalActions: number;
    validGuards: number;
    validActions: number;
    undefinedVariableReferences: number;
    potentialOverflows: number;
    contradictions: number;
  };
} {
  const warnings: GuardWarning[] = [];
  const stats = {
    totalGuards: 0,
    totalActions: 0,
    validGuards: 0,
    validActions: 0,
    undefinedVariableReferences: 0,
    potentialOverflows: 0,
    contradictions: 0,
  };

  // Validate variable definitions
  warnings.push(...validateVariableDefinitions(variables));

  // Analyze each transition
  for (const edge of edges) {
    const guard = typeof edge.data?.condition === 'string' ? edge.data.condition : '';
    const action = typeof edge.data?.action === 'string' ? edge.data.action : '';

    // Analyze guard
    if (guard && guard.trim()) {
      stats.totalGuards++;
      const guardResult = parseGuardExpression(guard, variables);

      if (guardResult.isValid) {
        stats.validGuards++;
      } else {
        warnings.push(...guardResult.warnings.map(w => ({
          ...w,
          location: {
            ...w.location,
            transitionId: edge.id,
          }
        })));
        stats.undefinedVariableReferences += guardResult.warnings.filter(
          w => w.type === 'undefined_variable'
        ).length;
      }

      // Check for potential contradictions
      const contradictionWarnings = checkGuardContradictions(guard, variables, edge.id);
      warnings.push(...contradictionWarnings);
      stats.contradictions += contradictionWarnings.length;
    }

    // Analyze action
    if (action && action.trim()) {
      stats.totalActions++;
      const actionResult = parseActionExpression(action, variables);

      if (actionResult.isValid) {
        stats.validActions++;
      } else {
        warnings.push(...actionResult.warnings.map(w => ({
          ...w,
          location: {
            ...w.location,
            transitionId: edge.id,
          }
        })));
        stats.undefinedVariableReferences += actionResult.warnings.filter(
          w => w.type === 'undefined_variable'
        ).length;
      }

      // Check for potential overflows/underflows
      const overflowWarnings = checkActionOverflows(action, variables, edge.id);
      warnings.push(...overflowWarnings);
      stats.potentialOverflows += overflowWarnings.length;
    }
  }

  // Check for unreachable transitions due to guards
  const unreachableWarnings = findUnreachableTransitions(nodes, edges, variables);
  warnings.push(...unreachableWarnings);

  // Check for EFSM non-determinism (multiple guards passing for same event)
  const nonDeterminismWarnings = detectEFSMNonDeterminism(nodes, edges, variables);
  warnings.push(...nonDeterminismWarnings);
  stats.contradictions += nonDeterminismWarnings.length;

  return { warnings, stats };
}

/**
 * Validate variable definitions for completeness
 */
function validateVariableDefinitions(variables: EFSMVariable[]): GuardWarning[] {
  const warnings: GuardWarning[] = [];
  const nameSet = new Set<string>();

  for (const variable of variables) {
    // Check for duplicate names
    if (nameSet.has(variable.name)) {
      warnings.push({
        type: 'ambiguous',
        severity: 'error',
        location: { variableName: variable.name },
        message: `Duplicate variable name: ${variable.name}`,
        suggestion: 'Variable names must be unique'
      });
    }
    nameSet.add(variable.name);

    // Check type-specific requirements
    switch (variable.type) {
      case 'int':
        if (variable.minValue === undefined || variable.maxValue === undefined) {
          warnings.push({
            type: 'unbounded',
            severity: 'error',
            location: { variableName: variable.name },
            message: `Integer variable ${variable.name} must have min and max bounds`,
            suggestion: 'Set minValue and maxValue for integer variables'
          });
        } else if (variable.minValue > variable.maxValue) {
          warnings.push({
            type: 'contradiction',
            severity: 'error',
            location: { variableName: variable.name },
            message: `Integer variable ${variable.name} has invalid bounds: min > max`,
            suggestion: 'Ensure minValue <= maxValue'
          });
        }

        // Check if initial value is within bounds
        if (variable.initialValue !== undefined) {
          const initVal = Number(variable.initialValue);
          if (variable.minValue !== undefined && initVal < variable.minValue) {
            warnings.push({
              type: 'underflow',
              severity: 'warning',
              location: { variableName: variable.name },
              message: `Initial value ${initVal} is less than minimum ${variable.minValue}`,
              suggestion: 'Set initial value within bounds'
            });
          }
          if (variable.maxValue !== undefined && initVal > variable.maxValue) {
            warnings.push({
              type: 'overflow',
              severity: 'warning',
              location: { variableName: variable.name },
              message: `Initial value ${initVal} exceeds maximum ${variable.maxValue}`,
              suggestion: 'Set initial value within bounds'
            });
          }
        }
        break;

      case 'enum':
        if (!variable.enumValues || variable.enumValues.length === 0) {
          warnings.push({
            type: 'unbounded',
            severity: 'error',
            location: { variableName: variable.name },
            message: `Enum variable ${variable.name} must have at least one value`,
            suggestion: 'Define enum values for this variable'
          });
        }

        // Check if initial value is valid
        if (variable.initialValue !== undefined && variable.enumValues) {
          if (!variable.enumValues.includes(String(variable.initialValue))) {
            warnings.push({
              type: 'type_mismatch',
              severity: 'warning',
              location: { variableName: variable.name },
              message: `Initial value '${variable.initialValue}' is not in enum values`,
              suggestion: `Choose from: ${variable.enumValues.join(', ')}`
            });
          }
        }
        break;

      case 'bool':
        // Boolean validation is straightforward
        if (variable.initialValue !== undefined && typeof variable.initialValue !== 'boolean') {
          warnings.push({
            type: 'type_mismatch',
            severity: 'warning',
            location: { variableName: variable.name },
            message: `Initial value for boolean variable should be true or false`,
            suggestion: 'Set initial value to true or false'
          });
        }
        break;
    }
  }

  return warnings;
}

/**
 * Check for contradictory guard conditions
 */
function checkGuardContradictions(
  guard: string,
  variables: EFSMVariable[],
  transitionId: string
): GuardWarning[] {
  const warnings: GuardWarning[] = [];

  // Simple pattern matching for obvious contradictions
  // e.g., "x > 5 && x < 3" or "flag && !flag"

  // Check for variable compared to itself with impossible conditions
  const patterns = [
    /(\w+)\s*>\s*(\d+)\s*&&\s*\1\s*<\s*(\d+)/g,  // x > 5 && x < 3
    /(\w+)\s*==\s*(\w+)\s*&&\s*\1\s*!=\s*\2/g,   // x == y && x != y
    /(\w+)\s*&&\s*!\1/g,                          // flag && !flag
    /!(\w+)\s*&&\s*\1/g,                          // !flag && flag
  ];

  for (const pattern of patterns) {
    const matches = guard.matchAll(pattern);
    for (const match of matches) {
      warnings.push({
        type: 'contradiction',
        severity: 'warning',
        location: {
          transitionId,
          expression: guard
        },
        message: `Potential contradiction in guard: ${match[0]}`,
        suggestion: 'Review guard logic for impossible conditions'
      });
    }
  }

  return warnings;
}

/**
 * Check for potential overflows in actions
 */
function checkActionOverflows(
  action: string,
  variables: EFSMVariable[],
  transitionId: string
): GuardWarning[] {
  const warnings: GuardWarning[] = [];
  const variableMap = new Map(variables.map(v => [v.name, v]));

  // Parse action to get assignments
  const result = parseActionExpression(action, variables);
  if (!result.isValid) return warnings;

  for (const { variable, expression } of result.assignments) {
    const varDef = variableMap.get(variable);
    if (!varDef || varDef.type !== 'int') continue;

    // Check for operations that might cause overflow
    // e.g., "x = x + 1" where x is at max value
    if (expression.includes('+') || expression.includes('*')) {
      warnings.push({
        type: 'overflow',
        severity: 'info',
        location: {
          transitionId,
          variableName: variable,
          expression: action
        },
        message: `Action may cause overflow for variable '${variable}'`,
        suggestion: `Ensure operations stay within bounds [${varDef.minValue}, ${varDef.maxValue}]`
      });
    }

    // Check for operations that might cause underflow
    if (expression.includes('-') || expression.includes('/')) {
      warnings.push({
        type: 'underflow',
        severity: 'info',
        location: {
          transitionId,
          variableName: variable,
          expression: action
        },
        message: `Action may cause underflow for variable '${variable}'`,
        suggestion: `Ensure operations stay within bounds [${varDef.minValue}, ${varDef.maxValue}]`
      });
    }
  }

  return warnings;
}

/**
 * Find transitions that are unreachable due to impossible guards
 */
function findUnreachableTransitions(
  nodes: FSMNode[],
  edges: FSMEdge[],
  variables: EFSMVariable[]
): GuardWarning[] {
  const warnings: GuardWarning[] = [];

  // Group edges by source state
  const edgesBySource = new Map<string, FSMEdge[]>();
  for (const edge of edges) {
    const list = edgesBySource.get(edge.source) || [];
    list.push(edge);
    edgesBySource.set(edge.source, list);
  }

  // For each state, check if any outgoing transitions can never be taken
  for (const [sourceId, outgoingEdges] of edgesBySource.entries()) {
    // Check for mutually exclusive guards
    for (let i = 0; i < outgoingEdges.length; i++) {
      for (let j = i + 1; j < outgoingEdges.length; j++) {
        const edge1 = outgoingEdges[i];
        const edge2 = outgoingEdges[j];

        // Only check edges with the same event
        if (edge1.data?.event && edge2.data?.event && edge1.data.event === edge2.data.event) {
          const guard1 = edge1.data.condition;
          const guard2 = edge2.data.condition;

          if (guard1 && guard2 && areGuardsMutuallyExclusive(guard1, guard2)) {
            warnings.push({
              type: 'ambiguous',
              severity: 'warning',
              location: {
                transitionId: edge2.id,
                stateId: sourceId,
                expression: guard2
              },
              message: `Transitions may have overlapping guards for event '${edge1.data.event}'`,
              suggestion: 'Ensure guards are mutually exclusive or prioritize transitions'
            });
          }
        }
      }
    }
  }

  return warnings;
}

/**
 * Check if two guards are mutually exclusive (simple heuristic)
 */
function areGuardsMutuallyExclusive(guard1: string, guard2: string): boolean {
  // This is a simplified check - full symbolic analysis would be more complex
  // For now, just check if they're obviously different
  return false; // Conservative: assume they might overlap
}

/**
 * Get all variables referenced in an expression
 */
export function getReferencedVariables(expression: string, variables: EFSMVariable[]): string[] {
  const result = parseGuardExpression(expression, variables);
  return result.variables;
}

/**
 * Detect EFSM non-determinism: multiple guards that can pass simultaneously
 * This is more sophisticated than FSM non-determinism - we need to check if
 * guards can evaluate to true at the same time for the same event.
 */
function detectEFSMNonDeterminism(
  nodes: FSMNode[],
  edges: FSMEdge[],
  variables: EFSMVariable[]
): GuardWarning[] {
  const warnings: GuardWarning[] = [];

  // Group edges by source state
  const edgesBySource = new Map<string, FSMEdge[]>();
  for (const edge of edges) {
    if (!edgesBySource.has(edge.source)) {
      edgesBySource.set(edge.source, []);
    }
    edgesBySource.get(edge.source)!.push(edge);
  }

  // Check each state for non-determinism
  for (const [stateId, stateEdges] of edgesBySource) {
    // Group by event type
    const edgesByEvent = new Map<string, FSMEdge[]>();
    for (const edge of stateEdges) {
      const event = edge.data?.event || '';
      if (!event) continue; // Skip edges without events

      if (!edgesByEvent.has(event)) {
        edgesByEvent.set(event, []);
      }
      edgesByEvent.get(event)!.push(edge);
    }

    // Check each event group for overlapping guards
    for (const [event, eventEdges] of edgesByEvent) {
      if (eventEdges.length < 2) continue; // Need at least 2 transitions

      // Check all pairs of transitions
      for (let i = 0; i < eventEdges.length; i++) {
        for (let j = i + 1; j < eventEdges.length; j++) {
          const edge1 = eventEdges[i];
          const edge2 = eventEdges[j];

          const guard1 = typeof edge1.data?.condition === 'string' ? edge1.data.condition.trim() : '';
          const guard2 = typeof edge2.data?.condition === 'string' ? edge2.data.condition.trim() : '';

          // If either has no guard, it's always non-deterministic
          if (!guard1 || !guard2) {
            const targetNode1 = nodes.find(n => n.id === edge1.target);
            const targetNode2 = nodes.find(n => n.id === edge2.target);

            warnings.push({
              type: 'non_deterministic',
              severity: 'error',
              location: {
                stateId,
                transitionId: edge1.id,
                expression: `Event: ${event}`
              },
              message: `Non-deterministic transitions: multiple transitions for event '${event}' without guards`,
              suggestion: `Add mutually exclusive guards or remove duplicate transitions to ${targetNode1?.data?.label} and ${targetNode2?.data?.label}`
            });
            continue;
          }

          // Check if guards can overlap
          const overlap = checkGuardOverlap(guard1, guard2, variables);
          if (overlap.canOverlap) {
            const targetNode1 = nodes.find(n => n.id === edge1.target);
            const targetNode2 = nodes.find(n => n.id === edge2.target);

            warnings.push({
              type: 'non_deterministic',
              severity: 'error',
              location: {
                stateId,
                transitionId: edge1.id,
                expression: `Guard 1: ${guard1}\nGuard 2: ${guard2}`
              },
              message: `EFSM non-determinism: guards may both evaluate to true for event '${event}'`,
              suggestion: overlap.example
                ? `Both guards can be true when ${overlap.example}. Make guards mutually exclusive (e.g., use <= vs >)`
                : `Ensure guards are mutually exclusive to avoid non-deterministic behavior between ${targetNode1?.data?.label} and ${targetNode2?.data?.label}`
            });
          }
        }
      }
    }
  }

  return warnings;
}

/**
 * Check if two guards can overlap (both be true at the same time)
 * Returns whether they can overlap and an example if found
 */
function checkGuardOverlap(
  guard1: string,
  guard2: string,
  variables: EFSMVariable[]
): { canOverlap: boolean; example?: string } {
  // Generate sample variable states to test
  const sampleStates = generateSampleStates(variables);

  // Test each sample state
  for (const state of sampleStates) {
    const result1 = evaluateGuard(guard1, state, variables);
    const result2 = evaluateGuard(guard2, state, variables);

    // If both evaluate to true, they overlap
    if (result1 === true && result2 === true) {
      const example = Object.entries(state)
        .map(([key, val]) => `${key} = ${val}`)
        .join(', ');
      return { canOverlap: true, example };
    }
  }

  // No overlap found in samples (but this isn't proof they never overlap)
  // For safety, we should assume they might overlap unless we can prove otherwise
  // This is a conservative approach

  // Try to do simple syntactic analysis
  const areMutuallyExclusive = checkMutualExclusivity(guard1, guard2);
  if (areMutuallyExclusive) {
    return { canOverlap: false };
  }

  // If we can't prove they're mutually exclusive, assume they might overlap
  // But don't report if we couldn't find a concrete example
  return { canOverlap: false };
}

/**
 * Generate sample variable states for testing guard overlap
 */
function generateSampleStates(variables: EFSMVariable[]): VariableState[] {
  if (variables.length === 0) return [{}];

  const states: VariableState[] = [];

  // For each variable, generate boundary and middle values
  function generateCombinations(index: number, currentState: VariableState) {
    if (index === variables.length) {
      states.push({ ...currentState });
      return;
    }

    const variable = variables[index];
    let sampleValues: (number | boolean | string)[] = [];

    switch (variable.type) {
      case 'int':
        const min = variable.minValue ?? 0;
        const max = variable.maxValue ?? 10;
        // Test boundary values and a few in between
        sampleValues = [min, min + 1, Math.floor((min + max) / 2), max - 1, max];
        // Remove duplicates
        sampleValues = [...new Set(sampleValues)].filter(v => v >= min && v <= max);
        break;

      case 'bool':
        sampleValues = [false, true];
        break;

      case 'enum':
        sampleValues = variable.enumValues || [];
        break;
    }

    for (const value of sampleValues) {
      currentState[variable.name] = value;
      generateCombinations(index + 1, currentState);
    }
  }

  generateCombinations(0, {});

  // Limit the number of combinations to avoid explosion
  return states.slice(0, 100);
}

/**
 * Check if two guards are syntactically mutually exclusive
 * This is a simple heuristic-based check
 */
function checkMutualExclusivity(guard1: string, guard2: string): boolean {
  // Pattern: x < N and x >= N are mutually exclusive
  const ltPattern = /(\w+)\s*<\s*(\d+)/;
  const gtePattern = /(\w+)\s*>=\s*(\d+)/;
  const gtPattern = /(\w+)\s*>\s*(\d+)/;
  const ltePattern = /(\w+)\s*<=\s*(\d+)/;
  const eqPattern = /(\w+)\s*==\s*(\d+)/;
  const neqPattern = /(\w+)\s*!=\s*(\d+)/;

  // Check for < vs >=
  const lt1 = guard1.match(ltPattern);
  const gte2 = guard2.match(gtePattern);
  if (lt1 && gte2 && lt1[1] === gte2[1] && lt1[2] === gte2[2]) {
    return true; // x < N and x >= N are mutually exclusive
  }

  // Check for > vs <=
  const gt1 = guard1.match(gtPattern);
  const lte2 = guard2.match(ltePattern);
  if (gt1 && lte2 && gt1[1] === lte2[1] && gt1[2] === lte2[2]) {
    return true; // x > N and x <= N are mutually exclusive
  }

  // Check for == vs !=
  const eq1 = guard1.match(eqPattern);
  const neq2 = guard2.match(neqPattern);
  if (eq1 && neq2 && eq1[1] === neq2[1] && eq1[2] === neq2[2]) {
    return true; // x == N and x != N are mutually exclusive
  }

  // Reverse checks
  const lt2 = guard2.match(ltPattern);
  const gte1 = guard1.match(gtePattern);
  if (lt2 && gte1 && lt2[1] === gte1[1] && lt2[2] === gte1[2]) {
    return true;
  }

  const gt2 = guard2.match(gtPattern);
  const lte1 = guard1.match(ltePattern);
  if (gt2 && lte1 && gt2[1] === lte1[1] && gt2[2] === lte1[2]) {
    return true;
  }

  const eq2 = guard2.match(eqPattern);
  const neq1 = guard1.match(neqPattern);
  if (eq2 && neq1 && eq2[1] === neq1[1] && eq2[2] === neq1[2]) {
    return true;
  }

  return false; // Can't prove mutual exclusivity
}
