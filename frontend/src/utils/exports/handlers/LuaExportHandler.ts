import { ExportHandler, ExportFormat, ExportResult, Protocol, ExportContext, Field } from '@/contracts';

export class LuaExportHandler implements ExportHandler {
  format: ExportFormat = {
    id: 'lua',
    name: 'Wireshark Dissector And ColorFilters',
    description: 'Generate Lua dissector script and colorfilters file for Wireshark<br><a href="https://www.wireshark.org/docs/wsug_html_chunked/ChCustColorizationSection.html" target="_blank" rel="noopener">How to import Wireshark colorfilters</a><br><a href="https://www.alphr.com/wireshark-use-lua-dissector/" target="_blank" rel="noopener">How to import Lua dissectors</a>',
    fileExtension: 'lua',
    mimeType: 'text/plain',
    icon: 'mdi-shark',
    supportsPreview: true,
    previewLanguage: 'lua'
  };

  async generate(protocol: Protocol, context: ExportContext): Promise<ExportResult> {
    try {
      const protocolName = protocol.name.toLowerCase().replace(/\s+/g, '_');
      const protocolDisplayName = protocol.name;

      // Generate dissector content
      let luaContent = this.generateHeader(protocolName, protocolDisplayName, protocol.description);
      luaContent += this.generateProtocolDefinition(protocolName);
      luaContent += this.generateFieldDefinitions(protocolName, protocol.fields, context);
      luaContent += this.generateDissectorFunction(protocolName, protocol.fields, context);
      luaContent += this.generateRegistration(protocolName, context.configuration?.udpPort);

      // Generate colorfilters content
      const colorfiltersContent = this.generateColorfiltersFile(protocolName, protocol.fields);

      // Check if we have field options to generate colorfilters
      const hasFieldOptions = protocol.fields.some(field =>
        !field.encapsulate && field.field_options && field.field_options.length > 0
      );

      if (hasFieldOptions) {
        // Multi-file export with colorfilters
        return {
          success: true,
          content: luaContent, // For preview
          files: [
            {
              content: luaContent,
              filename: `${protocolName}_dissector.${this.format.fileExtension}`,
              mimeType: this.format.mimeType
            },
            {
              content: colorfiltersContent,
              filename: `${protocolName}_colorfilters`,
              mimeType: 'text/plain'
            }
          ]
        };
      } else {
        // Single file export (no colorfilters needed)
        const blob = new Blob([luaContent], {
          type: this.format.mimeType + ';charset=utf-8',
        });

        return {
          success: true,
          content: luaContent,
          blob,
          filename: `${protocolName}_dissector.${this.format.fileExtension}`
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate Lua dissector'
      };
    }
  }

  validate(protocol: Protocol): { valid: boolean; errors?: string[] } {
    const errors: string[] = [];

    if (!protocol.name?.trim()) {
      errors.push('Protocol name is required for Lua export');
    }

    if (!protocol.fields || protocol.fields.length === 0) {
      errors.push('Protocol must have at least one field');
    }

    // Check for exportable fields (non-encapsulation)
    const exportableFields = protocol.fields?.filter(field => !field.encapsulate) || [];
    if (exportableFields.length === 0) {
      errors.push('No exportable fields found. Encapsulation fields cannot be exported to Lua dissectors.');
    }

    // Validate field names for Lua compatibility
    for (const field of protocol.fields || []) {
      if (field.encapsulate) continue;

      if (!this.isValidLuaIdentifier(field.id)) {
        errors.push(`Field ID '${field.id}' is not a valid Lua identifier`);
      }

      // Check for unsupported variable length fields without max length
      if (field.is_variable_length && (!field.max_length || field.max_length === 0)) {
        errors.push(`Variable length field '${field.display_name}' requires max_length for Wireshark dissector`);
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }

  private generateHeader(protocolName: string, displayName: string, description: string): string {
    return `-- ${displayName} Wireshark Dissector
-- Generated by Protocol Designer
-- ${description || 'No description provided'}
--
-- Usage: Place this file in Wireshark's plugins directory
-- Typically: ~/.local/lib/wireshark/plugins/ (Linux) or %APPDATA%\\Wireshark\\plugins (Windows)

`;
  }

  private generateProtocolDefinition(protocolName: string): string {
    return `-- Create the protocol
local ${protocolName}_proto = Proto("${protocolName}", "${protocolName.toUpperCase()} Protocol")

`;
  }

  private generateFieldDefinitions(protocolName: string, fields: Field[], context: ExportContext): string {
    let content = '-- Define protocol fields\nlocal fields = {}\n';

    for (const field of fields) {
      if (field.encapsulate) continue;

      const fieldName = this.sanitizeFieldName(field.id);
      const fieldDescription = field.description || field.display_name;
      const lengthBits = field.is_variable_length ?
        (field.max_length ? context.maxLengthToBits(field) : context.lengthToBits(field)) :
        context.lengthToBits(field);

      // Determine appropriate field type based on length
      let fieldType = 'uint8';
      let baseFormat = 'base.HEX';

      if (lengthBits <= 8) {
        fieldType = 'uint8';
      } else if (lengthBits <= 16) {
        fieldType = 'uint16';
      } else if (lengthBits <= 32) {
        fieldType = 'uint32';
      } else if (lengthBits <= 64) {
        fieldType = 'uint64';
      } else {
        fieldType = 'bytes'; // For larger fields
        baseFormat = 'base.NONE'; // bytes fields require specific base formats
      }

      content += `fields.${fieldName} = ProtoField.${fieldType}("${protocolName}.${fieldName}", "${fieldDescription}", ${baseFormat})\n`;

      // Add field options as value_string if they exist
      if (field.field_options && field.field_options.length > 0) {
        content += `local ${fieldName}_values = {\n`;
        for (const option of field.field_options) {
          content += `    [${option.value}] = "${option.name}",\n`;
        }
        content += '}\n';
        // Update field definition to use value_string
        content = content.replace(
          `fields.${fieldName} = ProtoField.${fieldType}("${protocolName}.${fieldName}", "${fieldDescription}", ${baseFormat})`,
          `fields.${fieldName} = ProtoField.${fieldType}("${protocolName}.${fieldName}", "${fieldDescription}", ${baseFormat}, ${fieldName}_values)`
        );
      }
    }

    content += `\n-- Register fields with protocol\n${protocolName}_proto.fields = fields\n\n`;
    return content;
  }

  private generateDissectorFunction(protocolName: string, fields: Field[], context: ExportContext): string {
    let content = `-- Dissector function
function ${protocolName}_proto.dissector(buffer, pinfo, tree)
    local length = buffer:len()
    if length == 0 then return end

    pinfo.cols.protocol = "${protocolName.toUpperCase()}"
    local subtree = tree:add(${protocolName}_proto, buffer(), "${protocolName.toUpperCase()} Protocol")

    local offset = 0
`;

    for (const field of fields) {
      if (field.encapsulate) continue;

      const fieldName = this.sanitizeFieldName(field.id);
      const lengthBits = field.is_variable_length ?
        (field.max_length ? context.maxLengthToBits(field) : context.lengthToBits(field)) :
        context.lengthToBits(field);
      const lengthBytes = Math.ceil(lengthBits / 8);

      content += `\n    -- ${field.display_name}\n`;
      content += `    if offset + ${lengthBytes} <= length then\n`;

      if (lengthBytes === 1) {
        content += `        subtree:add(fields.${fieldName}, buffer(offset, 1))\n`;
      } else if (lengthBytes === 2) {
        content += `        subtree:add(fields.${fieldName}, buffer(offset, 2))\n`;
      } else if (lengthBytes === 4) {
        content += `        subtree:add(fields.${fieldName}, buffer(offset, 4))\n`;
      } else if (lengthBytes === 8) {
        content += `        subtree:add(fields.${fieldName}, buffer(offset, 8))\n`;
      } else {
        content += `        subtree:add(fields.${fieldName}, buffer(offset, ${lengthBytes}))\n`;
      }

      if (field.field_options && field.field_options.length > 0) {
        content += `        \n        -- Display field option value in info column\n`;
        content += `        local ${fieldName}_value = buffer(offset, ${lengthBytes}):uint()\n`;

        for (let i = 0; i < field.field_options.length; i++) {
          const option = field.field_options[i];
          const condition = i === 0 ? 'if' : 'elseif';
          content += `        ${condition} ${fieldName}_value == ${option.value} then\n`;
          content += `            pinfo.cols.info:append(" [${option.name}]")\n`;
        }
        if (field.field_options.length > 0) {
          content += `        end\n`;
        }
      }

      content += `        offset = offset + ${lengthBytes}\n`;
      content += `    end\n`;
    }

    content += `
end

`;
    return content;
  }

  private generateColorfiltersFile(protocolName: string, fields: Field[]): string {
    let content = `# Wireshark colorfilters for ${protocolName.toUpperCase()} protocol\n`;
    content += `# Generated by Protocol Designer\n`;
    content += `# Import this file in Wireshark: View > Coloring Rules > Import\n`;
    content += `# File format: @name@filter@[foreground_color][background_color]\n\n`;

    for (const field of fields) {
      if (field.encapsulate || !field.field_options || field.field_options.length === 0) {
        continue;
      }

      const fieldName = this.sanitizeFieldName(field.id);

      for (const option of field.field_options) {
        // Generate color based on option value for consistency
        const color = this.generateColorFromValue(option.value);
        const filterName = `${protocolName.toUpperCase()} ${field.display_name} = ${option.name}`;
        const filterExpression = `${protocolName}.${fieldName} == ${option.value}`;

        content += `@${filterName}@${filterExpression}@${color.fg}${color.bg}\n`;
      }
    }

    return content;
  }

  /**
   * Generate a color based on option value
   * Uses a simple hash of the value to determine hue, with good contrast
   */
  private generateColorFromValue(value: number): { fg: string; bg: string } {
    // Create a simple hash from the value
    let hash = value;
    hash = ((hash << 5) - hash + value) & 0xffffffff;
    hash = Math.abs(hash);

    // Generate hue from hash (0-360 degrees)
    const hue = hash % 360;

    // Use HSL to RGB conversion for consistent, pleasant colors
    // Keep saturation moderate (60%) and lightness high (80%) for good readability
    const saturation = 0.6;
    const lightness = 0.8;

    const rgb = this.hslToRgb(hue / 360, saturation, lightness);

    // Convert to Wireshark's 16-bit color format (0-65535)
    const r16 = Math.round(rgb.r * 65535 / 255);
    const g16 = Math.round(rgb.g * 65535 / 255);
    const b16 = Math.round(rgb.b * 65535 / 255);

    return {
      fg: '[0,0,0]', // Black foreground for good contrast
      bg: `[${r16},${g16},${b16}]`
    };
  }

  /**
   * Convert HSL to RGB
   */
  private hslToRgb(h: number, s: number, l: number): { r: number; g: number; b: number } {
    let r, g, b;

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const hue2rgb = (p: number, q: number, t: number) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }

  private generateRegistration(protocolName: string, udpPort?: number): string {
    let content = `-- Register protocol with Wireshark
`;

    if (udpPort && udpPort > 0 && udpPort <= 65535) {
      content += `
-- Register for UDP port ${udpPort}
local udp_port = DissectorTable.get("udp.port")
udp_port:add(${udpPort}, ${protocolName}_proto)
`;
    } else {
      content += `-- Common options:
-- 1. Register for a specific UDP/TCP port
-- 2. Register for a specific Ethernet type
-- 3. Register as a heuristic dissector

-- Example: Register for UDP port 12345
-- local udp_port = DissectorTable.get("udp.port")
-- udp_port:add(12345, ${protocolName}_proto)

-- Example: Register for TCP port 54321
-- local tcp_port = DissectorTable.get("tcp.port")
-- tcp_port:add(54321, ${protocolName}_proto)

-- Example: Register for Ethernet type (adjust the type as needed)
-- local eth_type = DissectorTable.get("ethertype")
-- eth_type:add(0x1234, ${protocolName}_proto)

-- For testing purposes, you can register as a heuristic dissector
-- ${protocolName}_proto:register_heuristic("udp", function(buffer, pinfo, tree)
--     if buffer:len() < 4 then return false end
--     -- Add your heuristic logic here
--     ${protocolName}_proto.dissector(buffer, pinfo, tree)
--     return true
-- end)
`;
    }

    content += `
print("${protocolName.toUpperCase()} dissector loaded")
`;
    return content;
  }

  private sanitizeFieldName(fieldId: string): string {
    // Replace invalid characters with underscores and ensure it starts with letter or underscore
    let sanitized = fieldId.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
    if (!/^[a-zA-Z_]/.test(sanitized)) {
      sanitized = '_' + sanitized;
    }
    return sanitized;
  }

  private isValidLuaIdentifier(identifier: string): boolean {
    // Lua identifiers can start with letter or underscore, followed by letters, digits, or underscores
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier);
  }
}
